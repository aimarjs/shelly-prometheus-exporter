
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>shelly-exporter: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/aimar/shelly-prometheus-exporter/cmd/shelly-exporter/main.go (0.0%)</option>
				
				<option value="file1">github.com/aimar/shelly-prometheus-exporter/internal/client/client.go (0.0%)</option>
				
				<option value="file2">github.com/aimar/shelly-prometheus-exporter/internal/config/config.go (86.4%)</option>
				
				<option value="file3">github.com/aimar/shelly-prometheus-exporter/internal/metrics/metrics.go (0.0%)</option>
				
				<option value="file4">github.com/aimar/shelly-prometheus-exporter/internal/server/server.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "os"
        "os/signal"
        "syscall"

        "github.com/aimar/shelly-prometheus-exporter/internal/config"
        "github.com/aimar/shelly-prometheus-exporter/internal/server"
        "github.com/sirupsen/logrus"
        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var (
        version   = "dev"
        commit    = "unknown"
        buildTime = "unknown"
)

func main() <span class="cov0" title="0">{
        if err := newRootCmd().Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}

func newRootCmd() *cobra.Command <span class="cov0" title="0">{
        var cfgFile string

        cmd := &amp;cobra.Command{
                Use:   "shelly-exporter",
                Short: "Prometheus exporter for Shelly devices",
                Long: `Shelly Prometheus Exporter is a tool that scrapes metrics from Shelly devices
and exposes them in Prometheus format for monitoring and alerting.`,
                Version: fmt.Sprintf("%s (commit: %s, built: %s)", version, commit, buildTime),
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        // Bind flags to viper after command creation
                        if err := viper.BindPFlags(cmd.Flags()); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to bind flags: %w", err)
                        }</span>
                        <span class="cov0" title="0">return run(cfgFile)</span>
                },
        }

        <span class="cov0" title="0">cmd.Flags().StringVar(&amp;cfgFile, "config", "", "config file (default is $HOME/.shelly-exporter.yaml)")
        cmd.Flags().String("listen-address", ":8080", "Address to listen on for web interface and telemetry")
        cmd.Flags().String("metrics-path", "/metrics", "Path under which to expose metrics")
        cmd.Flags().String("log-level", "info", "Log level (debug, info, warn, error)")
        cmd.Flags().StringSlice("shelly-devices", []string{}, "List of Shelly device URLs (e.g., http://192.168.1.100)")
        cmd.Flags().Duration("scrape-interval", 30, "Interval between scrapes")
        cmd.Flags().Duration("scrape-timeout", 10, "Timeout for each scrape")
        cmd.Flags().Bool("tls-enabled", false, "Enable TLS for Shelly device connections")
        cmd.Flags().String("tls-ca-file", "", "CA certificate file for TLS verification")
        cmd.Flags().String("tls-cert-file", "", "Client certificate file for TLS")
        cmd.Flags().String("tls-key-file", "", "Client private key file for TLS")
        cmd.Flags().Bool("tls-insecure-skip-verify", false, "Skip TLS certificate verification")

        return cmd</span>
}

func run(cfgFile string) error <span class="cov0" title="0">{
        // Load configuration
        cfg, err := config.Load(cfgFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        // Setup logging
        <span class="cov0" title="0">logger := logrus.New()
        level, err := logrus.ParseLevel(cfg.LogLevel)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid log level: %w", err)
        }</span>
        <span class="cov0" title="0">logger.SetLevel(level)

        logger.WithFields(logrus.Fields{
                "version":    version,
                "commit":     commit,
                "build_time": buildTime,
        }).Info("Starting Shelly Prometheus Exporter")

        // Create server
        srv, err := server.New(cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create server: %w", err)
        }</span>

        // Setup graceful shutdown
        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())
        defer cancel()

        // Handle shutdown signals
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                sig := &lt;-sigChan
                logger.WithField("signal", sig).Info("Received shutdown signal")
                cancel()
        }</span>()

        // Start server
        <span class="cov0" title="0">if err := srv.Start(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("server error: %w", err)
        }</span>

        <span class="cov0" title="0">logger.Info("Server stopped")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package client

import (
        "context"
        "crypto/tls"
        "encoding/json"
        "fmt"
        "net/http"

        "github.com/aimar/shelly-prometheus-exporter/internal/config"
        "github.com/sirupsen/logrus"
)

// Client represents a client for interacting with Shelly devices
type Client struct {
        httpClient *http.Client
        logger     *logrus.Logger
        baseURL    string
}

// New creates a new Shelly client
func New(baseURL string, cfg *config.Config, logger *logrus.Logger) *Client <span class="cov0" title="0">{
        // Create HTTP client with TLS configuration
        httpClient := &amp;http.Client{
                Timeout: cfg.ScrapeTimeout,
        }

        if cfg.TLS.Enabled </span><span class="cov0" title="0">{
                tlsConfig := &amp;tls.Config{
                        InsecureSkipVerify: cfg.TLS.InsecureSkipVerify,
                }

                if cfg.TLS.CAFile != "" </span><span class="cov0" title="0">{
                        // TODO: Load CA certificate
                        _ = cfg.TLS.CAFile // Suppress unused variable warning
                }</span>

                <span class="cov0" title="0">if cfg.TLS.CertFile != "" &amp;&amp; cfg.TLS.KeyFile != "" </span><span class="cov0" title="0">{
                        // TODO: Load client certificate
                        _ = cfg.TLS.CertFile // Suppress unused variable warning
                        _ = cfg.TLS.KeyFile  // Suppress unused variable warning
                }</span>

                <span class="cov0" title="0">httpClient.Transport = &amp;http.Transport{
                        TLSClientConfig: tlsConfig,
                }</span>
        }

        <span class="cov0" title="0">return &amp;Client{
                httpClient: httpClient,
                logger:     logger,
                baseURL:    baseURL,
        }</span>
}

// BaseURL returns the base URL of the client
func (c *Client) BaseURL() string <span class="cov0" title="0">{
        return c.baseURL
}</span>

// GetStatus retrieves the status from a Shelly device
func (c *Client) GetStatus(ctx context.Context) (*StatusResponse, error) <span class="cov0" title="0">{
        // Try Pro3em RPC API first
        url := fmt.Sprintf("%s/rpc/Shelly.GetStatus", c.baseURL)

        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                // Try legacy API for Shelly 1PM
                resp.Body.Close()
                return c.getStatusLegacy(ctx)
        }</span>

        // Parse JSON response
        <span class="cov0" title="0">var status StatusResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;status); err != nil </span><span class="cov0" title="0">{
                resp.Body.Close()
                // Try legacy API for Shelly 1PM
                return c.getStatusLegacy(ctx)
        }</span>

        <span class="cov0" title="0">return &amp;status, nil</span>
}

// getStatusLegacy retrieves status using legacy API (for Shelly 1PM and Plug S)
func (c *Client) getStatusLegacy(ctx context.Context) (*StatusResponse, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/status", c.baseURL)

        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
        }</span>

        // Parse legacy JSON response
        <span class="cov0" title="0">var legacyStatus LegacyStatusResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;legacyStatus); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode JSON response: %w", err)
        }</span>

        // Convert legacy response to standard StatusResponse
        <span class="cov0" title="0">status := &amp;StatusResponse{
                Mac:     legacyStatus.Mac,
                Uptime:  legacyStatus.Uptime,
                RAMSize: legacyStatus.RAMSize,
                RAMFree: legacyStatus.RAMFree,
                FSSize:  legacyStatus.FSSize,
                FSFree:  legacyStatus.FSFree,
        }

        // Set system info
        status.Sys.Mac = legacyStatus.Mac
        status.Sys.Uptime = legacyStatus.Uptime
        status.Sys.RAMSize = legacyStatus.RAMSize
        status.Sys.RAMFree = legacyStatus.RAMFree
        status.Sys.FSSize = legacyStatus.FSSize
        status.Sys.FSFree = legacyStatus.FSFree

        // Set WiFi info
        status.Wifi.StaIP = legacyStatus.WifiSta.IP
        status.Wifi.SSID = legacyStatus.WifiSta.SSID
        status.Wifi.RSSI = legacyStatus.WifiSta.RSSI
        if legacyStatus.WifiSta.Connected </span><span class="cov0" title="0">{
                status.Wifi.Status = "got ip"
        }</span>

        // Set temperature
        <span class="cov0" title="0">status.Temperature.TC = legacyStatus.Temperature

        // Set relay info (Shelly 1PM and Plug S have one relay)
        if len(legacyStatus.Relays) &gt; 0 </span><span class="cov0" title="0">{
                status.Relays = legacyStatus.Relays
        }</span>

        // Set meter info (Shelly 1PM and Plug S have one meter)
        <span class="cov0" title="0">if len(legacyStatus.Meters) &gt; 0 </span><span class="cov0" title="0">{
                // Convert to EM format for consistency
                meter := legacyStatus.Meters[0]
                status.EM.AActPower = meter.Power
                status.EM.TotalActPower = meter.Power
                status.EMData.TotalAct = float64(meter.Total)
        }</span>

        <span class="cov0" title="0">return status, nil</span>
}

// GetMeters retrieves meter information from a Shelly device
func (c *Client) GetMeters(ctx context.Context) (*MetersResponse, error) <span class="cov0" title="0">{
        url := fmt.Sprintf("%s/meter/0", c.baseURL)

        req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create request: %w", err)
        }</span>

        <span class="cov0" title="0">resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
        }</span>

        // TODO: Parse JSON response
        <span class="cov0" title="0">return &amp;MetersResponse{}, nil</span>
}

// StatusResponse represents the status response from a Shelly device
type StatusResponse struct {
        // System information
        Sys struct {
                Mac              string `json:"mac"`
                RestartRequired  bool   `json:"restart_required"`
                Time             string `json:"time"`
                Unixtime         int64  `json:"unixtime"`
                LastSyncTs       int64  `json:"last_sync_ts"`
                Uptime           int    `json:"uptime"`
                RAMSize          int    `json:"ram_size"`
                RAMFree          int    `json:"ram_free"`
                RAMMinFree       int    `json:"ram_min_free"`
                FSSize           int    `json:"fs_size"`
                FSFree           int    `json:"fs_free"`
                CfgRev           int    `json:"cfg_rev"`
                KvsRev           int    `json:"kvs_rev"`
                ScheduleRev      int    `json:"schedule_rev"`
                WebhookRev       int    `json:"webhook_rev"`
                BtrelayRev       int    `json:"btrelay_rev"`
                AvailableUpdates struct {
                        Stable struct {
                                Version string `json:"version"`
                        } `json:"stable"`
                } `json:"available_updates"`
                ResetReason int `json:"reset_reason"`
        } `json:"sys"`

        // WiFi information
        Wifi struct {
                StaIP  string `json:"sta_ip"`
                Status string `json:"status"`
                SSID   string `json:"ssid"`
                RSSI   int    `json:"rssi"`
        } `json:"wifi"`

        // Cloud connection
        Cloud struct {
                Connected bool `json:"connected"`
        } `json:"cloud"`

        // MQTT connection
        MQTT struct {
                Connected bool `json:"connected"`
        } `json:"mqtt"`

        // Temperature sensor
        Temperature struct {
                ID int     `json:"id"`
                TC float64 `json:"tC"`
                TF float64 `json:"tF"`
        } `json:"temperature:0"`

        // Energy meter data
        EM struct {
                ID             int      `json:"id"`
                ACurrent       float64  `json:"a_current"`
                AVoltage       float64  `json:"a_voltage"`
                AActPower      float64  `json:"a_act_power"`
                AAprtPower     float64  `json:"a_aprt_power"`
                APF            float64  `json:"a_pf"`
                AFreq          float64  `json:"a_freq"`
                BCurrent       float64  `json:"b_current"`
                BVoltage       float64  `json:"b_voltage"`
                BActPower      float64  `json:"b_act_power"`
                BAprtPower     float64  `json:"b_aprt_power"`
                BPF            float64  `json:"b_pf"`
                BFreq          float64  `json:"b_freq"`
                CCurrent       float64  `json:"c_current"`
                CVoltage       float64  `json:"c_voltage"`
                CActPower      float64  `json:"c_act_power"`
                CAprtPower     float64  `json:"c_aprt_power"`
                CPF            float64  `json:"c_pf"`
                CFreq          float64  `json:"c_freq"`
                NCurrent       *float64 `json:"n_current"`
                TotalCurrent   float64  `json:"total_current"`
                TotalActPower  float64  `json:"total_act_power"`
                TotalAprtPower float64  `json:"total_aprt_power"`
        } `json:"em:0"`

        // Energy meter data (totals)
        EMData struct {
                ID                 int     `json:"id"`
                ATotalActEnergy    float64 `json:"a_total_act_energy"`
                ATotalActRetEnergy float64 `json:"a_total_act_ret_energy"`
                BTotalActEnergy    float64 `json:"b_total_act_energy"`
                BTotalActRetEnergy float64 `json:"b_total_act_ret_energy"`
                CTotalActEnergy    float64 `json:"c_total_act_energy"`
                CTotalActRetEnergy float64 `json:"c_total_act_ret_energy"`
                TotalAct           float64 `json:"total_act"`
                TotalActRet        float64 `json:"total_act_ret"`
        } `json:"emdata:0"`

        // Legacy fields for compatibility
        Mac       string `json:"mac"`
        Serial    string `json:"serial"`
        HasUpdate bool   `json:"has_update"`
        RAMSize   int    `json:"ram_size"`
        RAMFree   int    `json:"ram_free"`
        FSSize    int    `json:"fs_size"`
        FSFree    int    `json:"fs_free"`
        Uptime    int    `json:"uptime"`

        // Relay and meter information (for Shelly 1PM and Plug S)
        Relays []Relay `json:"relays"`
        Meters []Meter `json:"meters"`
}

// LegacyStatusResponse represents the legacy API response from Shelly 1PM and Plug S
type LegacyStatusResponse struct {
        WifiSta struct {
                Connected bool   `json:"connected"`
                SSID      string `json:"ssid"`
                IP        string `json:"ip"`
                RSSI      int    `json:"rssi"`
        } `json:"wifi_sta"`

        Cloud struct {
                Enabled   bool `json:"enabled"`
                Connected bool `json:"connected"`
        } `json:"cloud"`

        MQTT struct {
                Connected bool `json:"connected"`
        } `json:"mqtt"`

        Time              string  `json:"time"`
        Unixtime          int64   `json:"unixtime"`
        Serial            int     `json:"serial"`
        HasUpdate         bool    `json:"has_update"`
        Mac               string  `json:"mac"`
        Relays            []Relay `json:"relays"`
        Meters            []Meter `json:"meters"`
        Temperature       float64 `json:"temperature"`
        Overtemperature   bool    `json:"overtemperature"`
        TemperatureStatus string  `json:"temperature_status"`
        Update            struct {
                Status     string `json:"status"`
                HasUpdate  bool   `json:"has_update"`
                NewVersion string `json:"new_version"`
                OldVersion string `json:"old_version"`
        } `json:"update"`
        RAMSize int `json:"ram_size"`
        RAMFree int `json:"ram_free"`
        FSSize  int `json:"fs_size"`
        FSFree  int `json:"fs_free"`
        Uptime  int `json:"uptime"`
}

// MetersResponse represents the meters response from a Shelly device
type MetersResponse struct {
        Power     float64   `json:"power"`
        Overpower float64   `json:"overpower"`
        IsValid   bool      `json:"is_valid"`
        Timestamp int64     `json:"timestamp"`
        Counters  []float64 `json:"counters"`
        Total     int64     `json:"total"`
}

// Relay represents a relay in a Shelly device
type Relay struct {
        IsOn           bool   `json:"ison"`
        HasTimer       bool   `json:"has_timer"`
        TimerStarted   int64  `json:"timer_started"`
        TimerDuration  int64  `json:"timer_duration"`
        TimerRemaining int64  `json:"timer_remaining"`
        Overpower      bool   `json:"overpower"`
        IsValid        bool   `json:"is_valid"`
        Source         string `json:"source"`
}

// Meter represents a meter in a Shelly device
type Meter struct {
        Power     float64   `json:"power"`
        Overpower float64   `json:"overpower"`
        IsValid   bool      `json:"is_valid"`
        Timestamp int64     `json:"timestamp"`
        Counters  []float64 `json:"counters"`
        Total     int64     `json:"total"`
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "fmt"
        "time"

        "github.com/spf13/viper"
)

// Config holds all configuration for the Shelly Prometheus Exporter
type Config struct {
        // Server configuration
        ListenAddress string `mapstructure:"listen_address"`
        MetricsPath   string `mapstructure:"metrics_path"`

        // Logging configuration
        LogLevel string `mapstructure:"log_level"`

        // Shelly devices configuration
        ShellyDevices []string `mapstructure:"shelly_devices"`

        // Scraping configuration
        ScrapeInterval time.Duration `mapstructure:"scrape_interval"`
        ScrapeTimeout  time.Duration `mapstructure:"scrape_timeout"`

        // TLS configuration
        TLS TLSConfig `mapstructure:"tls"`
}

// TLSConfig holds TLS configuration for Shelly device connections
type TLSConfig struct {
        Enabled            bool   `mapstructure:"enabled"`
        CAFile             string `mapstructure:"ca_file"`
        CertFile           string `mapstructure:"cert_file"`
        KeyFile            string `mapstructure:"key_file"`
        InsecureSkipVerify bool   `mapstructure:"insecure_skip_verify"`
}

// Load loads configuration from file and environment variables
func Load(cfgFile string) (*Config, error) <span class="cov6" title="5">{
        v := viper.New()

        // Set default values
        setDefaults(v)

        // Enable reading from environment variables
        v.AutomaticEnv()

        // Set config file
        if cfgFile != "" </span><span class="cov6" title="5">{
                v.SetConfigFile(cfgFile)
        }</span> else<span class="cov0" title="0"> {
                v.SetConfigName(".shelly-exporter")
                v.SetConfigType("yaml")
                v.AddConfigPath(".")
                v.AddConfigPath("$HOME")
                v.AddConfigPath("/etc/shelly-exporter")
        }</span>

        // Read config file
        <span class="cov6" title="5">if err := v.ReadInConfig(); err != nil </span><span class="cov3" title="2">{
                if _, ok := err.(viper.ConfigFileNotFoundError); !ok </span><span class="cov3" title="2">{
                        return nil, fmt.Errorf("error reading config file: %w", err)
                }</span>
                // Config file not found is OK, we'll use defaults and env vars
        }

        // Unmarshal into struct
        <span class="cov4" title="3">var cfg Config
        if err := v.Unmarshal(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error unmarshaling config: %w", err)
        }</span>

        // Validate configuration
        <span class="cov4" title="3">if err := cfg.Validate(); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov3" title="2">return &amp;cfg, nil</span>
}

// setDefaults sets default configuration values
func setDefaults(v *viper.Viper) <span class="cov6" title="5">{
        v.SetDefault("listen_address", ":8080")
        v.SetDefault("metrics_path", "/metrics")
        v.SetDefault("log_level", "info")
        v.SetDefault("scrape_interval", 30*time.Second)
        v.SetDefault("scrape_timeout", 10*time.Second)
        v.SetDefault("tls.enabled", false)
        v.SetDefault("tls.insecure_skip_verify", false)
}</span>

// Validate validates the configuration
func (c *Config) Validate() error <span class="cov10" title="13">{
        if c.ListenAddress == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("listen_address cannot be empty")
        }</span>

        <span class="cov9" title="12">if c.MetricsPath == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("metrics_path cannot be empty")
        }</span>

        <span class="cov9" title="11">if len(c.ShellyDevices) == 0 </span><span class="cov3" title="2">{
                return fmt.Errorf("at least one shelly device must be configured")
        }</span>

        <span class="cov8" title="9">if c.ScrapeInterval &lt;= 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("scrape_interval must be positive")
        }</span>

        <span class="cov8" title="8">if c.ScrapeTimeout &lt;= 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("scrape_timeout must be positive")
        }</span>

        <span class="cov7" title="7">if c.ScrapeTimeout &gt;= c.ScrapeInterval </span><span class="cov1" title="1">{
                return fmt.Errorf("scrape_timeout must be less than scrape_interval")
        }</span>

        // Validate TLS configuration
        <span class="cov7" title="6">if c.TLS.Enabled </span><span class="cov4" title="3">{
                if c.TLS.CertFile != "" &amp;&amp; c.TLS.KeyFile == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("tls.key_file is required when tls.cert_file is set")
                }</span>
                <span class="cov3" title="2">if c.TLS.KeyFile != "" &amp;&amp; c.TLS.CertFile == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("tls.cert_file is required when tls.key_file is set")
                }</span>
        }

        <span class="cov5" title="4">return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package metrics

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/aimar/shelly-prometheus-exporter/internal/client"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/sirupsen/logrus"
)

// Collector collects metrics from Shelly devices
type Collector struct {
        clients []*client.Client
        logger  *logrus.Logger

        // Device metrics
        deviceInfo *prometheus.Desc
        deviceUp   *prometheus.Desc

        // WiFi metrics
        wifiConnected *prometheus.Desc
        wifiRSSI      *prometheus.Desc

        // Relay metrics
        relayState     *prometheus.Desc
        relayOverpower *prometheus.Desc

        // Power meter metrics
        powerWatts     *prometheus.Desc
        powerOverpower *prometheus.Desc
        energyTotal    *prometheus.Desc

        // Temperature metrics
        temperature     *prometheus.Desc
        overtemperature *prometheus.Desc

        // System metrics
        uptime  *prometheus.Desc
        ramFree *prometheus.Desc
        ramSize *prometheus.Desc
        fsFree  *prometheus.Desc
        fsSize  *prometheus.Desc

        // Cloud and MQTT metrics
        cloudConnected *prometheus.Desc
        mqttConnected  *prometheus.Desc

        // Update metrics
        updateAvailable *prometheus.Desc

        mu sync.RWMutex
}

// NewCollector creates a new metrics collector
func NewCollector(clients []*client.Client, logger *logrus.Logger) *Collector <span class="cov0" title="0">{
        return &amp;Collector{
                clients: clients,
                logger:  logger,

                deviceInfo: prometheus.NewDesc(
                        "shelly_device_info",
                        "Information about the Shelly device",
                        []string{"device", "mac", "serial", "firmware"},
                        nil,
                ),

                deviceUp: prometheus.NewDesc(
                        "shelly_device_up",
                        "Whether the Shelly device is responding",
                        []string{"device"},
                        nil,
                ),

                wifiConnected: prometheus.NewDesc(
                        "shelly_wifi_connected",
                        "Whether the Shelly device is connected to WiFi",
                        []string{"device", "ssid", "ip"},
                        nil,
                ),

                wifiRSSI: prometheus.NewDesc(
                        "shelly_wifi_rssi_dbm",
                        "WiFi signal strength in dBm",
                        []string{"device"},
                        nil,
                ),

                relayState: prometheus.NewDesc(
                        "shelly_relay_state",
                        "State of the relay (1 = on, 0 = off)",
                        []string{"device", "relay"},
                        nil,
                ),

                relayOverpower: prometheus.NewDesc(
                        "shelly_relay_overpower",
                        "Whether the relay is overpowered",
                        []string{"device", "relay"},
                        nil,
                ),

                powerWatts: prometheus.NewDesc(
                        "shelly_power_watts",
                        "Current power consumption in watts",
                        []string{"device", "meter"},
                        nil,
                ),

                powerOverpower: prometheus.NewDesc(
                        "shelly_power_overpower",
                        "Whether the power meter is overpowered",
                        []string{"device", "meter"},
                        nil,
                ),

                energyTotal: prometheus.NewDesc(
                        "shelly_energy_total_watthours",
                        "Total energy consumption in watt-hours",
                        []string{"device", "meter"},
                        nil,
                ),

                temperature: prometheus.NewDesc(
                        "shelly_temperature_celsius",
                        "Device temperature in Celsius",
                        []string{"device"},
                        nil,
                ),

                overtemperature: prometheus.NewDesc(
                        "shelly_overtemperature",
                        "Whether the device is overtemperature",
                        []string{"device"},
                        nil,
                ),

                uptime: prometheus.NewDesc(
                        "shelly_uptime_seconds",
                        "Device uptime in seconds",
                        []string{"device"},
                        nil,
                ),

                ramFree: prometheus.NewDesc(
                        "shelly_ram_free_bytes",
                        "Free RAM in bytes",
                        []string{"device"},
                        nil,
                ),

                ramSize: prometheus.NewDesc(
                        "shelly_ram_size_bytes",
                        "Total RAM size in bytes",
                        []string{"device"},
                        nil,
                ),

                fsFree: prometheus.NewDesc(
                        "shelly_filesystem_free_bytes",
                        "Free filesystem space in bytes",
                        []string{"device"},
                        nil,
                ),

                fsSize: prometheus.NewDesc(
                        "shelly_filesystem_size_bytes",
                        "Total filesystem size in bytes",
                        []string{"device"},
                        nil,
                ),

                cloudConnected: prometheus.NewDesc(
                        "shelly_cloud_connected",
                        "Whether the device is connected to Shelly Cloud",
                        []string{"device"},
                        nil,
                ),

                mqttConnected: prometheus.NewDesc(
                        "shelly_mqtt_connected",
                        "Whether the device is connected to MQTT",
                        []string{"device"},
                        nil,
                ),

                updateAvailable: prometheus.NewDesc(
                        "shelly_update_available",
                        "Whether a firmware update is available",
                        []string{"device"},
                        nil,
                ),
        }
}</span>

// Describe implements prometheus.Collector
func (c *Collector) Describe(ch chan&lt;- *prometheus.Desc) <span class="cov0" title="0">{
        ch &lt;- c.deviceInfo
        ch &lt;- c.deviceUp
        ch &lt;- c.wifiConnected
        ch &lt;- c.wifiRSSI
        ch &lt;- c.relayState
        ch &lt;- c.relayOverpower
        ch &lt;- c.powerWatts
        ch &lt;- c.powerOverpower
        ch &lt;- c.energyTotal
        ch &lt;- c.temperature
        ch &lt;- c.overtemperature
        ch &lt;- c.uptime
        ch &lt;- c.ramFree
        ch &lt;- c.ramSize
        ch &lt;- c.fsFree
        ch &lt;- c.fsSize
        ch &lt;- c.cloudConnected
        ch &lt;- c.mqttConnected
        ch &lt;- c.updateAvailable
}</span>

// Collect implements prometheus.Collector
func (c *Collector) Collect(ch chan&lt;- prometheus.Metric) <span class="cov0" title="0">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        for _, client := range c.clients </span><span class="cov0" title="0">{
                c.collectDeviceMetrics(client, ch)
        }</span>
}

// collectDeviceMetrics collects metrics for a single device
func (c *Collector) collectDeviceMetrics(client *client.Client, ch chan&lt;- prometheus.Metric) <span class="cov0" title="0">{
        device := client.BaseURL()

        // Get device status
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        status, err := client.GetStatus(ctx)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.WithError(err).WithField("device", device).Error("Failed to get device status")

                // Report device as down
                ch &lt;- prometheus.MustNewConstMetric(
                        c.deviceUp,
                        prometheus.GaugeValue,
                        0,
                        device,
                )
                return
        }</span>

        // Report device as up
        <span class="cov0" title="0">ch &lt;- prometheus.MustNewConstMetric(
                c.deviceUp,
                prometheus.GaugeValue,
                1,
                device,
        )

        // Device info
        ch &lt;- prometheus.MustNewConstMetric(
                c.deviceInfo,
                prometheus.GaugeValue,
                1,
                device,
                status.Sys.Mac,
                status.Sys.Mac,
                status.Sys.AvailableUpdates.Stable.Version,
        )

        // WiFi metrics
        wifiConnected := 0.0
        if status.Wifi.Status == "got ip" </span><span class="cov0" title="0">{
                wifiConnected = 1.0
        }</span>
        <span class="cov0" title="0">ch &lt;- prometheus.MustNewConstMetric(
                c.wifiConnected,
                prometheus.GaugeValue,
                wifiConnected,
                device,
                status.Wifi.SSID,
                status.Wifi.StaIP,
        )

        ch &lt;- prometheus.MustNewConstMetric(
                c.wifiRSSI,
                prometheus.GaugeValue,
                float64(status.Wifi.RSSI),
                device,
        )

        // Relay metrics
        for i, relay := range status.Relays </span><span class="cov0" title="0">{
                relayName := fmt.Sprintf("relay_%d", i)

                relayState := 0.0
                if relay.IsOn </span><span class="cov0" title="0">{
                        relayState = 1.0
                }</span>
                <span class="cov0" title="0">ch &lt;- prometheus.MustNewConstMetric(
                        c.relayState,
                        prometheus.GaugeValue,
                        relayState,
                        device,
                        relayName,
                )

                overpower := 0.0
                if relay.Overpower </span><span class="cov0" title="0">{
                        overpower = 1.0
                }</span>
                <span class="cov0" title="0">ch &lt;- prometheus.MustNewConstMetric(
                        c.relayOverpower,
                        prometheus.GaugeValue,
                        overpower,
                        device,
                        relayName,
                )</span>
        }

        // Power meter metrics - Phase A
        <span class="cov0" title="0">ch &lt;- prometheus.MustNewConstMetric(
                c.powerWatts,
                prometheus.GaugeValue,
                status.EM.AActPower,
                device,
                "phase_a",
        )

        // Power meter metrics - Phase B
        ch &lt;- prometheus.MustNewConstMetric(
                c.powerWatts,
                prometheus.GaugeValue,
                status.EM.BActPower,
                device,
                "phase_b",
        )

        // Power meter metrics - Phase C
        ch &lt;- prometheus.MustNewConstMetric(
                c.powerWatts,
                prometheus.GaugeValue,
                status.EM.CActPower,
                device,
                "phase_c",
        )

        // Total power
        ch &lt;- prometheus.MustNewConstMetric(
                c.powerWatts,
                prometheus.GaugeValue,
                status.EM.TotalActPower,
                device,
                "total",
        )

        // Energy totals
        ch &lt;- prometheus.MustNewConstMetric(
                c.energyTotal,
                prometheus.CounterValue,
                status.EMData.TotalAct,
                device,
                "total",
        )

        // Temperature metrics
        ch &lt;- prometheus.MustNewConstMetric(
                c.temperature,
                prometheus.GaugeValue,
                status.Temperature.TC,
                device,
        )

        // No overtemperature flag in this API, set to 0
        ch &lt;- prometheus.MustNewConstMetric(
                c.overtemperature,
                prometheus.GaugeValue,
                0,
                device,
        )

        // System metrics
        ch &lt;- prometheus.MustNewConstMetric(
                c.uptime,
                prometheus.CounterValue,
                float64(status.Sys.Uptime),
                device,
        )

        ch &lt;- prometheus.MustNewConstMetric(
                c.ramFree,
                prometheus.GaugeValue,
                float64(status.Sys.RAMFree),
                device,
        )

        ch &lt;- prometheus.MustNewConstMetric(
                c.ramSize,
                prometheus.GaugeValue,
                float64(status.Sys.RAMSize),
                device,
        )

        ch &lt;- prometheus.MustNewConstMetric(
                c.fsFree,
                prometheus.GaugeValue,
                float64(status.Sys.FSFree),
                device,
        )

        ch &lt;- prometheus.MustNewConstMetric(
                c.fsSize,
                prometheus.GaugeValue,
                float64(status.Sys.FSSize),
                device,
        )

        // Cloud and MQTT metrics
        cloudConnected := 0.0
        if status.Cloud.Connected </span><span class="cov0" title="0">{
                cloudConnected = 1.0
        }</span>
        <span class="cov0" title="0">ch &lt;- prometheus.MustNewConstMetric(
                c.cloudConnected,
                prometheus.GaugeValue,
                cloudConnected,
                device,
        )

        mqttConnected := 0.0
        if status.MQTT.Connected </span><span class="cov0" title="0">{
                mqttConnected = 1.0
        }</span>
        <span class="cov0" title="0">ch &lt;- prometheus.MustNewConstMetric(
                c.mqttConnected,
                prometheus.GaugeValue,
                mqttConnected,
                device,
        )

        // Update metrics
        updateAvailable := 0.0
        if status.Sys.AvailableUpdates.Stable.Version != "" </span><span class="cov0" title="0">{
                updateAvailable = 1.0
        }</span>
        <span class="cov0" title="0">ch &lt;- prometheus.MustNewConstMetric(
                c.updateAvailable,
                prometheus.GaugeValue,
                updateAvailable,
                device,
        )</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package server

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/aimar/shelly-prometheus-exporter/internal/client"
        "github.com/aimar/shelly-prometheus-exporter/internal/config"
        "github.com/aimar/shelly-prometheus-exporter/internal/metrics"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "github.com/sirupsen/logrus"
)

// Server represents the HTTP server for the Shelly Prometheus Exporter
type Server struct {
        config  *config.Config
        logger  *logrus.Logger
        server  *http.Server
        clients []*client.Client
}

// New creates a new server instance
func New(cfg *config.Config, logger *logrus.Logger) (*Server, error) <span class="cov0" title="0">{
        // Create clients for each Shelly device
        var clients []*client.Client
        for _, deviceURL := range cfg.ShellyDevices </span><span class="cov0" title="0">{
                client := client.New(deviceURL, cfg, logger)
                clients = append(clients, client)
        }</span>

        // Create metrics collector
        <span class="cov0" title="0">collector := metrics.NewCollector(clients, logger)
        prometheus.MustRegister(collector)

        // Create HTTP server
        mux := http.NewServeMux()

        // Health check endpoint
        mux.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusOK)
                if _, err := w.Write([]byte("OK")); err != nil </span><span class="cov0" title="0">{
                        logrus.Errorf("Failed to write health check response: %v", err)
                }</span>
        })

        // Metrics endpoint
        <span class="cov0" title="0">mux.Handle(cfg.MetricsPath, promhttp.Handler())

        // Root endpoint with basic information
        mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "text/html")
                fmt.Fprintf(w, `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Shelly Prometheus Exporter&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Shelly Prometheus Exporter&lt;/h1&gt;
    &lt;p&gt;Prometheus metrics are available at &lt;a href="%s"&gt;%s&lt;/a&gt;&lt;/p&gt;
    &lt;p&gt;Health check is available at &lt;a href="/health"&gt;/health&lt;/a&gt;&lt;/p&gt;
    &lt;h2&gt;Configured Devices&lt;/h2&gt;
    &lt;ul&gt;
`, cfg.MetricsPath, cfg.MetricsPath)

                for _, device := range cfg.ShellyDevices </span><span class="cov0" title="0">{
                        fmt.Fprintf(w, "        &lt;li&gt;%s&lt;/li&gt;\n", device)
                }</span>

                <span class="cov0" title="0">fmt.Fprintf(w, `    &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;`)</span>
        })

        <span class="cov0" title="0">server := &amp;http.Server{
                Addr:         cfg.ListenAddress,
                Handler:      mux,
                ReadTimeout:  15 * time.Second,
                WriteTimeout: 15 * time.Second,
                IdleTimeout:  60 * time.Second,
        }

        return &amp;Server{
                config:  cfg,
                logger:  logger,
                server:  server,
                clients: clients,
        }, nil</span>
}

// Start starts the HTTP server
func (s *Server) Start(ctx context.Context) error <span class="cov0" title="0">{
        // Start server in a goroutine
        go func() </span><span class="cov0" title="0">{
                s.logger.WithField("address", s.config.ListenAddress).Info("Starting HTTP server")

                if err := s.server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        s.logger.WithError(err).Error("HTTP server error")
                }</span>
        }()

        // Wait for context cancellation
        <span class="cov0" title="0">&lt;-ctx.Done()

        // Shutdown server gracefully
        s.logger.Info("Shutting down HTTP server")

        shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if err := s.server.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                s.logger.WithError(err).Error("Error during server shutdown")
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Stop stops the HTTP server
func (s *Server) Stop() error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        return s.server.Shutdown(ctx)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
